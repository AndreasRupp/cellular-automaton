#include "mex.hpp"
#include "mexAdapter.hpp"

#include <iostream>

#include <CAM/cellular_automaton.hxx>

/*!***********************************************************************************************
 * \brief   Domain size values.
 *
 * \tparam  nx       Number of rows of the matrix.
 * \tparam  ny       Number of columns of the matrix. Defaults to create square matrix.
 ************************************************************************************************/
static constexpr unsigned int nx = NX_MATLAB_VAL;
static constexpr unsigned int ny = NY_MATLAB_VAL;
/*!***********************************************************************************************
 * \brief   Array containing tentative index shifts of direct neighbors.
 ************************************************************************************************/
template <unsigned int nx, unsigned int ny>
constexpr std::array<int, 4> cellular_automaton<nx, ny>::direct_neigh_;
/*!***********************************************************************************************
 * \brief   Maximum unsigned integer.
 ************************************************************************************************/
template <unsigned int nx, unsigned int ny>
constexpr unsigned int cellular_automaton<nx, ny>::uint_max;
/*!***********************************************************************************************
 * \brief   Smallest (negative) double.
 ************************************************************************************************/
template <unsigned int nx, unsigned int ny>
constexpr double cellular_automaton<nx, ny>::double_min;
/*!***********************************************************************************************
 * \brief   Mex function for MATLAB.
 ************************************************************************************************/
class MexFunction : public matlab::mex::Function
{
 public:
  /*!***********************************************************************************************
   * \brief   Takes input arguments and prints possible outputs.
   *
   * \param   outputs     Output arguments.
   * \param   inputs      Input arguments.
   ************************************************************************************************/
  void operator()(matlab::mex::ArgumentList outputs, matlab::mex::ArgumentList inputs)
  {
    check_arguments(outputs, inputs);

    const unsigned int n_moves = inputs[0][0];
    const double porosity = inputs[1][0];
    const double jump_param = inputs[2][0];
    const unsigned int output_rate = inputs[3][0];
    matlab::data::TypedArray<double> results = std::move(inputs[4]);
    matlab::data::TypedArray<double> measures = std::move(inputs[5]);
    const bool print_random_seed = inputs[6][0];

    cellular_automaton<nx, ny> domain(porosity, jump_param,
                                      inputs.size() == 8 ? (unsigned int)inputs[7][0] : 0U);

    if (print_random_seed)
      std::cout << "The random seed is " << domain.random_seed() << "." << std::endl;

    if (output_rate != 0)
    {
      if (results.getNumberOfElements() != 0)
      {
        const std::array<unsigned int, nx* ny>& domain_fields = domain.fields();
        for (unsigned int k = 0; k < nx * ny; ++k)
          results[k][0] = domain_fields[k];
      }
      if (measures.getNumberOfElements() != 0)
      {
        const std::array<double, 6> meas = domain.eval_measures();
        for (unsigned int k = 0; k < 6; ++k)
          measures[k][0] = meas[k];
      }
    }

    for (unsigned int i = 0; i < n_moves; ++i)
    {
      domain.move_particles();

      if (output_rate != 0 && (i + 1) % output_rate == 0)
      {
        if (results.getNumberOfElements() != 0)
        {
          const std::array<unsigned int, nx* ny>& domain_fields = domain.fields();
          for (unsigned int k = 0; k < nx * ny; ++k)
            results[k][(1 + i) / output_rate] = domain_fields[k];
        }
        if (measures.getNumberOfElements() != 0)
        {
          const std::array<double, 6> meas = domain.eval_measures();
          for (unsigned int k = 0; k < 6; ++k)
            measures[k][(1 + i) / output_rate] = meas[k];
        }
      }
    }

    outputs[0] = std::move(results);
    outputs[1] = std::move(measures);
  }
  /*!***********************************************************************************************
   * \brief   Checks arguments.
   *
   * \param   outputs     Output arguments.
   * \param   inputs      Input arguments.
   ************************************************************************************************/
  void check_arguments(matlab::mex::ArgumentList outputs, matlab::mex::ArgumentList inputs)
  {
    std::shared_ptr<matlab::engine::MATLABEngine> matlabPtr = getEngine();
    matlab::data::ArrayFactory factory;

    if (inputs.size() < 7 || inputs.size() > 8)
    {
      matlabPtr->feval(
        u"error", 0,
        std::vector<matlab::data::Array>({factory.createScalar("7 or 8 inputs required")}));
    }

    if (inputs[0].getNumberOfElements() != 1)
    {
      matlabPtr->feval(u"error", 0,
                       std::vector<matlab::data::Array>(
                         {factory.createScalar("The number of steps must be a scalar")}));
    }

    if (inputs[0].getType() != matlab::data::ArrayType::INT32 || (int)inputs[0][0] < 0)
    {
      matlabPtr->feval(u"error", 0,
                       std::vector<matlab::data::Array>(
                         {factory.createScalar("The number of steps must be a positive integer")}));
    }

    if (inputs[1].getNumberOfElements() != 1)
    {
      matlabPtr->feval(
        u"error", 0,
        std::vector<matlab::data::Array>({factory.createScalar("The porosity must be a scalar")}));
    }

    if (inputs[1].getType() != matlab::data::ArrayType::DOUBLE || (double)inputs[1][0] < 0 ||
        (double)inputs[1][0] > 1)
    {
      matlabPtr->feval(u"error", 0,
                       std::vector<matlab::data::Array>({factory.createScalar(
                         "The porosity must be a double in range from 0 to 1")}));
    }

    if (inputs[2].getType() != matlab::data::ArrayType::DOUBLE || (double)inputs[2][0] < 0)
    {
      matlabPtr->feval(u"error", 0,
                       std::vector<matlab::data::Array>({factory.createScalar(
                         "The jump parameter must be a non-negative double")}));
    }

    if (inputs[2].getNumberOfElements() != 1)
    {
      matlabPtr->feval(u"error", 0,
                       std::vector<matlab::data::Array>(
                         {factory.createScalar("The jump parameter must be a scalar")}));
    }

    if (inputs[3].getType() != matlab::data::ArrayType::INT32 || (int)inputs[3][0] < 0)
    {
      matlabPtr->feval(u"error", 0,
                       std::vector<matlab::data::Array>(
                         {factory.createScalar("The output rate must be a positive integer")}));
    }

    if (inputs[3].getNumberOfElements() != 1)
    {
      matlabPtr->feval(u"error", 0,
                       std::vector<matlab::data::Array>(
                         {factory.createScalar("The output rate must be a scalar")}));
    }

    if (inputs[4].getDimensions().size() != 2)
    {
      if (inputs[4].getDimensions()[0] != nx * ny &&
          inputs[4].getDimensions()[1] != (int)inputs[0][0] + 1)
      {
        matlabPtr->feval(
          u"error", 0,
          std::vector<matlab::data::Array>({factory.createScalar(
            "The results matrix must be a m-by-n matrix, "
            "where m is the number of solid pixels and n is the number of outputs.")}));
      }
    }

    if (inputs[5].getDimensions().size() != 2)
    {
      if (inputs[5].getDimensions()[0] != nx * ny &&
          inputs[5].getDimensions()[1] != (int)inputs[0][0] + 1)
      {
        matlabPtr->feval(u"error", 0,
                         std::vector<matlab::data::Array>(
                           {factory.createScalar("The measures matrix must be a 6-by-n matrix, "
                                                 "where n is the number of outputs.")}));
      }
    }

    if (inputs[6].getNumberOfElements() != 1)
    {
      matlabPtr->feval(u"error", 0,
                       std::vector<matlab::data::Array>({factory.createScalar(
                         "The indicator for the output of the random seed must be a scalar")}));
    }

    if (inputs[6].getType() != matlab::data::ArrayType::INT8 ||
        ((int)inputs[6][0] != 0 && (int)inputs[6][0] != 1))
    {
      matlabPtr->feval(
        u"error", 0,
        std::vector<matlab::data::Array>({factory.createScalar(
          "The indicator for the output of the random seed must be true (1) or false (0).")}));
    }

    if (inputs.size() > 7)
    {
      if (inputs[7].getNumberOfElements() != 1)
      {
        matlabPtr->feval(u"error", 0,
                         std::vector<matlab::data::Array>({factory.createScalar(
                           "The number of the random seed must be a scalar")}));
      }

      if (inputs[7].getType() != matlab::data::ArrayType::INT64 || (int)inputs[7][0] < 0)
      {
        matlabPtr->feval(u"error", 0,
                         std::vector<matlab::data::Array>({factory.createScalar(
                           "The number of the random seed must be a non-negative integer")}));
      }
    }
  }
};
